블로킹 소켓
*블로킹
 디바이스에 처리 요청을 걸어 놓고 응답을 대기하는 함수를 호출할 때 스레드에서 발생하는 대기현상.
소켓뿐만 아니라 파일 핸들에 대한 함수를 호출했을 때도,
이러한 대기 현상이 발생하는 것을 모두 블로킹이라고 한다.

*수신 버퍼가 가득 차면 발생하는 현상
 수신 함수가 수신 버퍼에서 데이터를 꺼내는 속도가 운영 체제가 수신 버퍼의 데이터를
채우는 속도보다 느리면
-> TCP송신 함수로 송신 버퍼에 데이터를 쌓는 속도보다 수신 함수로 수신 버퍼에서 데이터를
꺼내는 속도가 느리다고 해서 TCP연결은 끊어지지 않음.(속도가 느린쪽에 맞추어 작동)
-> UDP송신 함수로 송신 버퍼에 데이터를 쌓는 속도보다 수신 함수로 수신
버퍼에서 데이터를 꺼내는 속도가 느리면 데이터그램 유실 발생.

*논블록 소켓의 장점
1. 스레드 블로킹이 없으므로 중도 취소 같은 통제가 가능하다.
2. 스레드 개수가 1개이거나 적어도 소켓을 여러 개 다룰 수 있다.
3. 스레드 개수가 적거나 1개이므로 연산량 낭비하지 않음. 호출 스택 메모리도 낭비하지 않음.

*논블록 소켓의 단점
1. 소켓I/O 함수가 리턴한 코드가 would block인 경우 재시도 호출 낭비가 발생한다.
2. 소켓I/O 함수를 호출할 때 입력하는 데이터 블록에 대한 복사 연산 발생.
3. connect()함수는재시도 호출을 하지 않지만, send() 함수나 receive()함수는 재시도
호출해야 하는 API가 일관되지 않는다는 문제가 있다.

*Overlapped I/O 백그라운드에서 액세스로 인한 주의사항
Overlapped I/O 함수는 즉시 리턴되지만, 운영체제로 해당 I/O 실행이 별도로 동시간대에 진행되는 상태임.
운영체제는 소켓 함수에 인자로 들어갔던 데이터 블록을 백그라운드에서 액세스한다.
호출한 Overlapped I/O 전용 함수가 비동기로 하는 일이 완료될 때 까지는 소켓API에
인자로 넘긴 데이터 블록을 제거하거나 내용을 변경해서는 안됨.
Overlapped status 구조체 또는 운영체제에서 백그라운드로 액세스 중이므로
중간에 없애가너 내용을 변경해서도 안된다.

*epoll
-> 소켓이 I/O 가능 상태가 되면 이를 감지해서 사용자에게 알림을 해 주는 역할을 함, 이때
어떤 소켓이 I/O 가능 상태인지 알려 준다.

*Overlapped 자료 구조
-> Overlapped I/O를 위해서는 WSAOVERLAPPED라는 자료구조를 만들어서 모든 Send/Recv에
 초기화 해서 넣어주어야 한다.
또한, send/recv는 사용할 수 없고 WSASend/WSARecv 를 사용해야 한다.
struct SOCKETINFO
 { 
	WSAOVERLAPPED overlapped;
	 WSABUF dataBuffer; 
	SOCKET socket; char messageBuffer[MAX_BUFFER];
 }; 
map <SOCKET, SOCKETINFO> clients;

*IOCP
->IOCP는 소켓의 Overlapped I/O가 완료되면 이를 감지해서 사용자에게 알려 주는 역할을 한다.
사용자는 IOCP에서 I/O가 완료되었음을 알려 주는 완료 신호를 꺼낼 수 있다.
소켓 개수가 1만 개라고 하더라도 이 중에서 I/O가 완료된 것들만 IOCP를 이용해서
바로 얻을 수 있기 때문에, 모든 소켓에서 루프를 돌지 않아도 된다.
