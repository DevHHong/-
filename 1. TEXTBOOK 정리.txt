*멀티스레드 프로그래밍은 언제 해야할까.
- 기기에 있는 CPU를 모두 활용해야 할 때
(EX. 일인칭 슈팅 게임은 클라이언트 하나에 초당 30번의 요청을 처리함.
이러한 클라이언트가 서버 기기에 1만 개 접속을 요청할 경우 초당 30만번의 처리 필요.
최악의 경우 30만 번을 처리해야 할 서버가 초당 1만 번밖에 처리하지 못하는 상황)

*스레드 정체
- "두 가지 일을 동시에 하라" 라고 시켰을 때.
 운영체제는 두개의 작업을 각각 다른 Core에서 실행한다.
 코어에 개수가 부족하면 컨텍스트 스위칭을 하면서 시분할 처리를 한다.
 
*임계 영역과 뮤텍스
 경쟁 상태를 해결하는 여러 방법 중 하나
 "내가 X를 사용하고 있으면 다른 스레드는 X를 건드리지 않고 기다린다. 현재 스레드가 X를 다 사용할 때까지"
뮤텍스 : 상호배재(Mutual Exclusion)의 줄임말.
뮤텍스 사용 방법 :
1. X, Y를 보호하는 뮤텍스 MX를 만듭니다.
2. 스레드는 X, Y를 건드리기 전에 MX에 "사용권을 얻겟다."라고 요청합니다.
3. 스레드는 X,Y를 액세스합니다.
4. 액세스가 끝나면 MX에 "사용권을 놓겟다."라고 요청합니다.
--코드로 표현하기.
std::mutex mx
mx.lock();
read(x);
write(y);
sum(x,y)
mx.unlock();

뮤텍스를 너무 잘게 나누면.
1. 오히려 프로그램 성능이 떨어짐 -> 뮤텍스를 액세스하는 과정 자체가 무겁기 때문.
2. 프로그램이 매우 복잡해짐, 특히 교착 상태(dead lock)문제가 쉽게 발생.

지나치게 자잘한 임계 영역
class Player
{
	mutex m_positionCritSec;
	Vector3 m_position;
	mutex m_nameCritSec;
	string m_name;
	mutex m_hpCritSec;
	int m_hp;
}

*교착 상태
두 스레드가 서로를 기다리는 상황
스레드 1은 스레드 2가 하던 일이 끝날 때까지 기다리는데,
정작 스레드2는 스레드1이 하던 일이 끝날 때까지 기다리는 상황
->이러한 두 스레드는 영원히 멈추고 있다.

게임 서버에서 교착 상태가 되면 발생하는 현상.
1. CPU 사용량이 현저히 낮거나 0%, 동시접속자 수와 상관없음
2. 클라이언트가 서버를 이용할 수 없음, 예를 들어 로그인을 못하거나 뭔가 요청을 보냈는데 응답이 오지않음.

CRITICAL_SECTION을 쓰는 방법
CRITICAL_SECTION은 <windows.h>에서 제공하는 mutex 변수의 타입이다. 지금은 C++11의 mutex를 사용하면 된다.

*잠금 순서의 규칙
여러 뮤텍스를 사용할 때 교착 상태를 예방하려면
-> 각 뮤텍스의 잠금 순서를 먼저 그래프로 그려둔다.
그리고 잠금을 할 때는 잠금 순서 그래프를 보면서 거구로 잠근 것이 없는지 체크 해야 한다.

여러 뮤텍스를 사용할 때 교착 상태를 예방하려면
-> 각 뮤텍스의 잠금 순서를 먼저 그래프로 그려둔다.
그리고 잠금을 할 때는 잠금 순서 그래프를 보면서 거꾸로 잠근 것이 없는지 체크 해야 한다.

*병렬성과 시리얼 병목
병렬성과 시리얼 병목
병렬성(parallelism) : 여러 CPU가 각 스레드의 연산을 실행하여 동시 처리량을 올리는 것
시리얼 병목(serial bottleneck) : 병렬로 실행되게 프로그램을 만들었는데 정작 한 CPU만 연산으 수행하는 현상

* 싱글 스레드 게임 서버
싱글스레드 서버를 구동하는 경우 CPU 개수만큼 프로세스를 띄우는 것이 일반적
1. 방 개수만큼 스레드나 프로세스가 있으면 스레드나 프로세스 간 컨텍스트 스위치의 횟수가 증가
2. 따라서 같은 동시접속자를 처리하는 서버라고 하더라도 실제로 처리할 수 있는 동시접속자 수를 크게 떨어뜨림.

*멀티 스레드 게임 서버
멀티스레드로 서버를 개발하는 경우(1,2,3,4는 해결가능하나, 5는 멀티스레드가 아니면 해결 불가능 => 5의 경우가 아니면 멀티스레드로 가면 안됨)
1. 서버 프로세스를 많이 띄우기 곤란할 때.
예를 들어 프로세스당 로딩해야 하는 게임 정보의 용량이 매우 클 때 (특히 MMO게임 서버)
2. 서버 한 대의 프로세스가 여러 CPU의 연산량을 동원해야 할 만큼 많은 연산을 할 때
3. 코루틴이나 비동기I/O함수를 쓸 수 없고 디바이스 타임이 발생할 때
4. 서버 인스턴스를 서버 기기당 하나만 두어야 할 때
5. 서로 다른 방이 같은 메모리 공간을 엑세스 해야 할 때

*스레드 풀링
멀티스레드 모델의 게임 서버를 개발할 때 스레드는 몇 개 만들고, 각 스레드는 무엇을 위해 일을 하게 만들면 좋을까?
-> 어떤 서버의 주 역할이 CPU 연산만 하는 스레드라면(즉, 디바이스 타임이 없다면) 스레드 풀의
스레드 개수는 서버의 CPU개수(=모든 코어의 개수)와 동일하게 잡아도 충분함
->서버에서 데이터베이스나 파일 등 다른 것에 액세스하면서 디바이스 타임이 발생할 때 스레드 개수는 CPU개수보다 많아야 함
->작업이 없으면 스레드 들은 스레드 풀에서 대기하고 있어야 하고(block상태),
작업이 들어오면 깨어나서 작업을 실행해야 한다.(대기의 구현 => 이벤트)

*이벤트
->이벤트 : 잠자는 스레드를 깨우는 도구
Reset : 이벤트가 없음, 정수 값으로 표현하자면 0
Set : 이벤트가 있음, 정수 값으로 표현하자면 1

*원자 조작
원자 조작(atomic operation)
뮤텍스나 임계 영역 잠금 없이도 여러 스레드가 안전하게 접근할 수 있는 것을 의미
원자 조작은 하드웨어 기능이며, 대부분의 컴파일러는 원자 조작 기능을 쓸 수 있게 함
원자 조작은 32비트나 64비트의 변수 타입에 여러 스레드가 접근할 때 한 스레드씩만 처리됨을 보장

*멀티스레드 프로그래밍의 흔한 실수들
읽기와 쓰기 모두에 잠금하지 않기
메모리에 값을 쓰고 있는데 다른 스레드가 그것을 읽으면 망가질 수 있다는 것은 인지하지만,
그냥 값을 읽고만 있으며 잠금을 하지 않더라도 안전하다는 막연한 생각 때문에 발생
